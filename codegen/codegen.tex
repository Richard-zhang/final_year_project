\chapter{Type-safe code generation from SPar}
SPar has two components: Core representing the unit of computation and Proc as a skeleton of the computation, describing the communication patterns. Naturally, the process of code generation from SPar should be divided into two parts correspondingly. We choose to make two parts independent of each other so that it's possible to swap the code generation strategy of one component without modifying another one.

The procedure of code generation is standard: transformation. We start our programs in a high level DSL and run a series of transformation to low-level DSL. SPar expressions are converted to a low-level EDSL which is then transformed to an abstract syntax tree (AST) of C (TODO cite the package). The generated code is obtained by pretty printing the AST.
\section{Instr: A low-level EDSL for channel communication}
In Proc, we have high-level actions like select, broadcast and branch abstracting implementation details, i.e variable declaration, variable assignment, channel initialization, channel communication and channel deletion. Hence, we need to define a EDSL containing instructions related to these low-level operations. We name it Instr. A Spar programs will be translated to a sequence of Instr. 

When we design Instr, we keep the simplicity in mind so Instr is not coupled with any fancy language feature related to some specific target languages. Any reasonable target language with a channel communication library can be easily converted from Instr.
\subsection{Syntax and semantic}
\begin{listing}
    \inputminted{Haskell}{codegen/instr.hs} 
    \caption{The syntax of Instr in Haskell with accompanying low-level data types}
    \label{codegen:code:instr}
\end{listing}
The definition of Instr is seen in \coref{codegen:code:instr}. \hask{Channel} is our abstract representation of Channel in Instr. It is indexed by a type a from the reified type \hask{ReprType a}. More details of this reified type will be introduced in \secref{codegen:sec:repr}. This type parameter preserves type in channel initialization hence make sure the value to be sent or received in this channel has the same type as this channel. This is necessary because for some target languages, the channel are typed. Similarly, type parameters in \hask{Exp} have the same functionality. \hask{Exp} is just a wrapper of the expression in Core. In later stages, we will take care of code generation of \hask{Exp} along with \hask{Instr}. \hask{Instr} defines the set of statements that will be generated and \hask{Exp} represents the sequential computation, which is a value that will be generated.

The semantic of Instr operations are similar to what their names suggest. \hask{CInitChan} represents operations that initialize a channel according to the given type and cid. \hask{CDeleteChan} will destroy a channel. \hask{CSend} operation sends the value \hask{Exp a} through the Channel. \hask{CRecv} action means the value received in the channel will be assigned to variable whose postfix name is the int field. \hask{CEnd} means the instruction exits with the value \hask{Exp a}. \hask{CDecla} and \hask{CAssgn} are instructions for variable declaration and assignment. The type of the variable is determined by \hask{ReprType a} and the value is \hask{Exp a}. \hask{CBranch} and \hask{CSelect} are used to express conditional control flow of the Instr languages. SPar action like broadcast are built on top of these operations. For \hask{CBranch}, the first field represents the value of Either type to be received via the channel and two \hask{Seq Instr}s represents the sequence of \hask{Instr}s in the left branch and the right branch. For \hask{CSelect}, the first field represents the variable containing Either value and the second field field represents the variable whose value is assigned by the end results of instructions from either the left branch or the right branch. The third and fourth fields represent the instructions in the left branch and the right branch.

\subsection{Representation types} \label{codegen:sec:repr}
SPar programs cannot be fully parametric since the target languages of code generation from SPar are usually less expressive, i.e, they do not treat function type \hask{a->b} as a value, and are less efficient when processing with some specific form of data, i.e, languages targeting GPUs are usually more productive in dealing with array of floating point number while slow in working with aggregate structures \cite{mcdonellTypesafeRuntimeCode}. 
\begin{listing}
    \inputminted{Haskell}{codegen/repr.hs}    
    \caption{The definition of representation types}
    \label{codegen:code:repr}
\end{listing}
\begin{listing}
    \inputminted{Haskell}{codegen/const.hs} 
    \caption{An example usage of reified type in the code generation}
    \label{codegen:code:const}
\end{listing}
Hence, we need to restrict the set of types allowed in SPar. We achieve this using the type class \hask{Repr} and corresponding reified type \hask{ReprType} (shown in \coref{codegen:code:repr}). \hask{Repr} determines the set of type allow in SPar. Reified type \hask{ReprType} will be used to alter the behaviors of code generation based on the type. This can be simply done by pattern matching because reified types are values in Haskell \cite{ReifiedTypeHaskellWiki}. To be more concrete, \coref{codegen:code:const} gives a demo. \hask{constToCExpr} is function that handle code generation from constant value to expression in C programming languages. By pattern matching, we vary the behaviors of code generation so that constants with different types has their own way to be represented in C.

In conclusion, we allow the following type: numerical type like \hask{Float} and \hask{Int}, the unit type \hask{()}, the label type which is used in the code generation of select and branch and the aggregate type: list, product and sum that are built recursively, to be expressed in SPar.

\section{Compilation from SPar to Instr}
% \subsection{Two stages of compilation}
\subsection{Transformation from Proc to Instr}
As described in the previous section, Instr contains a data type called \hask{Exp} which is a wrapper of Core expression. Compiling Core to Instr is hence not difficult. The challenge of compiling Core is mainly how to compile it to a specific target language. This will be discussed in the next subsection.  

In this section, we will explain how we transform operations in Proc to Instr. Generally speaking, each Proc operation is mapped to a sequence of actions in Instr. The transformation algorithm from a Proc expression to a sequence of Instr can be implemented easily by traversing Proc expression, applying the mapping and collecting the results by concatenation. This is an advantage of using free monad technique to build the AST because Proc expression can be treated as a data structures and traversing recursive data structures can be easily done in Haskell. In addition, operations like \hask{Recv} which involves continuation whose type is \hask{Core a -> next} in their constructors are treated differently than those operations whose constructors only have a value type \hask{next}. The latter is easy to implement, we can simply call the traversing function recursively. For the former, we have to pass an expression whose type is \hask{Core a} to the continuation so that we can recursively call the traverse function recursively on the results of applying value to the continuation. The answer to what Core expression should be used is \hask{Var} denoting variable. Passing a unique variable to the continuation gives us \hask{next} inexpensively and we will define where does values of variables comes from for each operations in Proc. 

We have introduced the general principle to the readers. Now let us dig into details of translation rules for each operations. 

\begin{itemize}
    \item[Pure:] It is the base case in free monad. Hence it is mapped to the \hask{CEnd} instruction.
    \item[Send:] It is mapped to a sequence of three instructions. First of all, We declared a temporary variable using \hask{CDecla} and then assign the value that will be sent to this variable using \hask{CAssgn} and send the content of the variable via the specific channel. The problem of how make sure the same channel is used in a send-and-receive pair will be discussed in the next sub chapter.
    \item[Recv:] It is the reverse of send operation. Firstly, it declares a new variable with \hask{CDecla} and use \hask{CRecv} to assign the value received from the sender to this variable. Notice that the recv has a continuation, we will pass the variable declared in the first instr to the continuation to traverse the Proc expression recursively as discussed above. 
    \item[Select:] It is a more complicated operations. Its constructor contains two continuation: one for left branch and one for right branch. Hence for this instruction, we need to declared two variable to passed into continuations. The value of both variables is assigned by the Core expression whose value is a Either type. Besides, we need to send label indicating whether the execution of the left branch or the right branch of the receiver is selected. Its value is assigned by the either value as well and the sending operation is done by \hask{CSend}. Finally, we call the transforming function recursively on the left branch and right branch and combine the results using \hask{CSelect}.
    \item[Broadcast:] The mapping from Broadcast is similar to that of Select. The only difference is that the former sends to a list of receivers while the latter sends to a single receiver. So in this operation, we will have multiple \hask{CSend} corresponding to each receiver.  
    \item[Branch:] It is the reverse of the Select operation. So it will use \hask{CRecv} to receive a label from the sender and call recursively on two branches and finally use \hask{CBranch} to collect results.
\end{itemize}
\subsection{Strategies for channel allocations}
Channel allocations is important because correction allocation is essential in making sure the correctness and deadlock-free of generated code. Besides correctness concerns, we are also want to reduce the amount of channels creations hence increase performances. 

In the first iteration, inspired by the linearity of channels in the $\pi$ calculus, we choose to allocate a one-time channel for each send-and-receive pair. All channels' buffer size is one because of the linearity. Send action will initialize a channel and Receive action will destroy this channel once it receive the value. We use the ensure the same channel is used for the pair. During the transformation, we use a map of queue whose key is a pair of sender id  and receiver id. When visiting the send action, it will push the channel into the queue and the corresponding received operation will pop the channel from the queue. Because we've ensured the duality of all processes in the system, we can claim the channel is right for each send-and-receiver pair. However, we realize this strategy is complicate to implement and not resource efficient since too many channels are initialized.

In the second iteration, we come up with a more efficient and simple strategy. The buffer size of all channels is still one due to the same reason about linearity. However, we decide to only allocate one channel for a pair of sender and receiver. We will not destroy the channel after the value has received and will reuse the channel for the next communication. When all processes have returned, we will destroy all channels at once. For this strategy, we have simplified the state from a map of queues of channels to a map of channels.
% \subsection{Type preservation}
\subsection{Monad for code generation}
\begin{listing}[ht]
    \inputminted{Haskell}{codegen/monad.hs} 
    \caption{States required during the traversal}
    \label{codegen:code:monad}
\end{listing}
From the last two subsections, we need to maintain a number of states during the compilation process. Hence we define a state monad to be used during the traversal. The \hask{CodeGenState} is the collection of states with different purposes and it is shown in \coref{codegen:code:monad}. \hask{chanTable} is the map we required during the channel allocation. \hask{varNext} represents the next variable id to used. It will increment by one every time we declare a new variable. It helps us make sure the variable names are unique. \hask{chanNext} has the similar functionality ensuring the uniqueness of channel names. \hask{dataStructCollect} is the set of compound type we encounter during the traversal. With this states, we know what kind of data structures whose definitions will be generated before the generation of executing code.

\section{Code generation to C: from Instr to C}
The last piece of jigsaw is compilation from a sequence of Instr to C. This process is rather simple but trivial. This is simply done by transforming the sequence of Instr to a C AST. We used an open source library: language-c \cite{LanguagecAnalysisGeneration} to represent C AST in Haskell and pretty printing the C AST gives us the generated code. This method can be generalized to any target language. As for the implementation of channel communication in C, we used another open source library: chan \cite{treatPureImplementationGo2019} whose internal is based on shared memory. In the following subsections, we will present some design choices during this final step.
\subsection{Representations of Core data type in C}
\subsection{Compiling Core to C}
\subsection{The structure of generated code}
\section{Conclusion}
With the completion of code generation, we deliver the results we promised in the introduction section. We have implemented a end-to-end process that will generate low-level parallel code from a high-level languages embedded with a flexible backend that can target multiple languages with ease. Now, it is time to evaluate the performances of our achievement with quantitative measurements.   
% \subsubsection{Data type in C}
% \subsection{Optimization for common recursive data types in C}
% \subsection{Memory management}