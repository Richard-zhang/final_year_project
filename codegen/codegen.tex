\chapter{Type-safe code generation from SPar} \label{chap:cg}
SPar has two components: Core representing the unit of computation and Proc as a skeleton of the computation, describing the communication patterns. Naturally, the process of code generation from SPar should be divided into two parts correspondingly. We choose to make two parts independent of each other so that it's possible to swap the code generation strategy of one component without modifying another one.

The procedure of code generation is standard: transformation. We start our programs in a high level DSL and run a series of transformation to low-level DSL. SPar expressions are converted to a low-level EDSL which is then transformed to an abstract syntax tree (AST) of C (TODO cite the package). The generated code is obtained by pretty printing the AST.
\section{Instr: A low-level EDSL for channel communication}
In Proc, we have high-level actions like select, broadcast and branch abstracting implementation details, i.e variable declaration, variable assignment, channel initialization, channel communication and channel deletion. Hence, we need to define a EDSL containing instructions related to these low-level operations. We name it Instr. A Spar programs will be translated to a sequence of Instr. 

When we design Instr, we keep the simplicity in mind so Instr is not coupled with any fancy language feature related to some specific target languages. Any reasonable target language with a channel communication library can be easily converted from Instr.
\subsection{Syntax and semantic}
\begin{listing}
    \inputminted{Haskell}{codegen/instr.hs} 
    \caption{The syntax of Instr in Haskell with accompanying low-level data types}
    \label{codegen:code:instr}
\end{listing}
The definition of Instr is seen in \coref{codegen:code:instr}. \hask{Channel} is our abstract representation of Channel in Instr. It is indexed by a type a from the reified type \hask{ReprType a}. More details of this reified type will be introduced in \secref{codegen:sec:repr}. This type parameter preserves type in channel initialization hence make sure the value to be sent or received in this channel has the same type as this channel. This is necessary because for some target languages, the channel are typed. Similarly, type parameters in \hask{Exp} have the same functionality. \hask{Exp} is just a wrapper of the expression in Core. In later stages, we will take care of code generation of \hask{Exp} along with \hask{Instr}. \hask{Instr} defines the set of statements that will be generated and \hask{Exp} represents the sequential computation, which is a value that will be generated.

The semantic of Instr operations are similar to what their names suggest. \hask{CInitChan} represents operations that initialize a channel according to the given type and cid. \linebreak \hask{CDeleteChan} will destroy a channel. \hask{CSend} operation sends the value \hask{Exp a} through the Channel. \hask{CRecv} action means the value received in the channel will be assigned to variable whose postfix name is the int field. \hask{CEnd} means the instruction exits with the value \hask{Exp a}. \hask{CDecla} and \hask{CAssgn} are instructions for variable declaration and assignment. The type of the variable is determined by \hask{ReprType a} and the value is \hask{Exp a}. \hask{CBranch} and \hask{CSelect} are used to express conditional control flow of the Instr languages. SPar action like broadcast are built on top of these operations. For \hask{CBranch}, the first field represents the value of Either type to be received via the channel and two \hask{Seq Instr}s represents the sequence of \hask{Instr}s in the left branch and the right branch. For \hask{CSelect}, the first field represents the variable containing Either value and the second field field represents the variable whose value is assigned by the end results of instructions from either the left branch or the right branch. The third and fourth fields represent the instructions in the left branch and the right branch.

\subsection{Representation types} \label{codegen:sec:repr}
SPar programs cannot be fully parametric since the target languages of code generation from SPar are usually less expressive, i.e, they do not treat function type \hask{a->b} as a value, and are less efficient when processing with some specific form of data, i.e, languages targeting GPUs are usually more productive in dealing with array of floating point number while slow in working with aggregate structures \cite{mcdonellTypesafeRuntimeCode}. 
\begin{listing}
    \inputminted{Haskell}{codegen/repr.hs}    
    \caption{The definition of representation types}
    \label{codegen:code:repr}
\end{listing}
\begin{listing}
    \inputminted{Haskell}{codegen/const.hs} 
    \caption{An example usage of reified type in the code generation}
    \label{codegen:code:const}
\end{listing}
Hence, we need to restrict the set of types allowed in SPar. We achieve this using the type class \hask{Repr} and corresponding reified type \hask{ReprType} (shown in \coref{codegen:code:repr}). \hask{Repr} determines the set of type allow in SPar. Reified type \hask{ReprType} will be used to alter the behaviors of code generation based on the type. This can be simply done by pattern matching because reified types are values in Haskell \cite{ReifiedTypeHaskellWiki}. To be more concrete, \coref{codegen:code:const} gives a demo. \hask{constToCExpr} is function that handle code generation from constant value to expression in C programming languages. By pattern matching, we vary the behaviors of code generation so that constants with different types has their own way to be represented in C.

In conclusion, we allow the following type: numerical type like \hask{Float} and \hask{Int}, the unit type \hask{()}, the label type which is used in the code generation of select and branch and the aggregate type: list, product and sum that are built recursively, to be expressed in SPar.

\section{Compilation from SPar to Instr}
% \subsection{Two stages of compilation}
\subsection{Transformation from Proc to Instr}
As described in the previous section, Instr contains a data type called \hask{Exp} which is a wrapper of Core expression. Compiling Core to Instr is hence not difficult. The challenge of compiling Core is mainly how to compile it to a specific target language. This will be discussed in the next subsection.  

In this section, we will explain how we transform operations in Proc to Instr. Generally speaking, each Proc operation is mapped to a sequence of actions in Instr. The transformation algorithm from a Proc expression to a sequence of Instr can be implemented easily by traversing Proc expression, applying the mapping and collecting the results by concatenation. This is an advantage of using free monad technique to build the AST because Proc expression can be treated as a data structures and traversing recursive data structures can be easily done in Haskell. In addition, operations like \hask{Recv} which involves continuation whose type is \hask{Core a -> next} in their constructors are treated differently than those operations whose constructors only have a value type \hask{next}. The latter is easy to implement, we can simply call the traversing function recursively. For the former, we have to pass an expression whose type is \hask{Core a} to the continuation so that we can recursively call the traverse function recursively on the results of applying value to the continuation. The answer to what Core expression should be used is \hask{Var} denoting variable. Passing a unique variable to the continuation gives us \hask{next} inexpensively and we will define where does values of variables comes from for each operations in Proc. 

We have introduced the general principle to the readers. Now let us dig into details of translation rules for each operations. 

\begin{itemize}
    \item \textbf{Pure. } It is the base case in free monad. Hence it is mapped to the \hask{CEnd} instruction.
    \item \textbf{Send. } It is mapped to a sequence of three instructions. First of all, We declared a temporary variable using \hask{CDecla} and then assign the value that will be sent to this variable using \hask{CAssgn} and send the content of the variable via the specific channel. The problem of how make sure the same channel is used in a send-and-receive pair will be discussed in the next sub chapter.
    \item \textbf{Recv. } It is the reverse of send operation. Firstly, it declares a new variable with \hask{CDecla} and use \hask{CRecv} to assign the value received from the sender to this variable. Notice that the recv has a continuation, we will pass the variable declared in the first instr to the continuation to traverse the Proc expression recursively as discussed above. 
    \item \textbf{Select. } It is a more complicated operations. Its constructor contains two continuation: one for left branch and one for right branch. Hence for this instruction, we need to declared two variable to passed into continuations. The value of both variables is assigned by the Core expression whose value is a Either type. Besides, we need to send label indicating whether the execution of the left branch or the right branch of the receiver is selected. Its value is assigned by the either value as well and the sending operation is done by \hask{CSend}. Finally, we call the transforming function recursively on the left branch and right branch and combine the results using \hask{CSelect}.
    \item \textbf{Broadcast. } The mapping from Broadcast is similar to that of Select. The only difference is that the former sends to a list of receivers while the latter sends to a single receiver. So in this operation, we will have multiple \hask{CSend} corresponding to each receiver.  
    \item \textbf{Branch. } It is the reverse of the Select operation. So it will use \hask{CRecv} to receive a label from the sender and call recursively on two branches and finally use \hask{CBranch} to collect results.
\end{itemize}
\subsection{Strategies for channel allocations}
Channel allocations is important because correction allocation is essential in making sure the correctness and deadlock-free of generated code. Besides correctness concerns, we are also want to reduce the amount of channels creations hence increase performances. 

In the first iteration, inspired by the linearity of channels in the $\pi$ calculus, we choose to allocate a one-time channel for each send-and-receive pair. All channels' buffer size is one because of the linearity. Send action will initialize a channel and Receive action will destroy this channel once it receive the value. We use the ensure the same channel is used for the pair. During the transformation, we use a map of queue whose key is a pair of sender id  and receiver id. When visiting the send action, it will push the channel into the queue and the corresponding received operation will pop the channel from the queue. Because we've ensured the duality of all processes in the system, we can claim the channel is right for each send-and-receiver pair. However, we realize this strategy is complicate to implement and not resource efficient since too many channels are initialized.

In the second iteration, we come up with a more efficient and simple strategy. The buffer size of all channels is still one due to the same reason about linearity. However, we decide to only allocate one channel for a pair of sender and receiver. We will not destroy the channel after the value has received and will reuse the channel for the next communication. When all processes have returned, we will destroy all channels at once. For this strategy, we have simplified the state from a map of queues of channels to a map of channels.
% \subsection{Type preservation}
\subsection{Monad for code generation}
\begin{listing}[ht]
    \inputminted{Haskell}{codegen/monad.hs} 
    \caption{States required during the traversal}
    \label{codegen:code:monad}
\end{listing}
From the last two subsections, we need to maintain a number of states during the compilation process. Hence we define a state monad to be used during the traversal. The \hask{CodeGenState} is the collection of states with different purposes and it is shown in \coref{codegen:code:monad}. \hask{chanTable} is the map we required during the channel allocation. \hask{varNext} represents the next variable id to used. It will increment by one every time we declare a new variable. It helps us make sure the variable names are unique. \hask{chanNext} has the similar functionality ensuring the uniqueness of channel names. \hask{dataStructCollect} is the set of compound type we encounter during the traversal. With this states, we know what kind of data structures whose definitions will be generated before the generation of executing code.

\section{Code generation to C: from Instr to C}
The last piece of jigsaw is compilation from a sequence of Instr to C. This process is rather simple but trivial. This is simply done by transforming the sequence of Instr to a C AST. We used an open source library: language-c \cite{LanguagecAnalysisGeneration} to represent C AST in Haskell and pretty printing the C AST gives us the generated code. This method can be generalized to any target language. As for the implementation of channel communication in C, we used another open source library: chan \cite{treatPureImplementationGo2019} whose internal is based on shared memory. In the following subsections, we will present some design choices during this final step.
\subsection{Representations of Core data type in C}
\begin{listing}[ht]
    \inputminted{C}{codegen/data.c} 
    \caption{Compound data type in C}
    \label{codegen:code:data}
\end{listing}
The first challenge we face is how to represent data structure in C. For primitive data type like Int or Float, a simple one-to-one mapping is sufficed. It is hard to deal with compound data type in C. First of all, C does not support polymorphic type. Hence, we choose to generate specific data type for every different compound data type even though they have the same structure. We have a way to name the generated data type to avoid name duplication. The naming simply reflects the structure of the data types with its elemental type. For example, \hask{(Int, (Int, ()))} is converted to Prod-Int-Prod-Int-Unit and \hask{Either (Either () (Int, Int)) (Int, Int)} is convert to Sum-Sum-unit-Prod-int-int-Prod-int-int. In this project, all compound types are formed by sum type and product type. The product type will be converted to a struct with two field in C. The sum type is represented by the tagged union type. Tagged union is a struct with two field. The value of the first field indicates whether it is a left value or right value and the value of second field is a union type containing either the left value or right value. We also implement a sorting algorithm based on the depth of compound type so that all necessary data types have been defined before the definition of the compound types. An example of what \hask{Either Int (Int, Int)} will be converted to is shown in \coref{codegen:code:data}.

Another challenge is representation of the recursive type. From the type theory, we learn that a list of int can be expressed as $\mu a. () + \text{Int} \times a$. We might reuse the idea from the last paragraph to generated recursive type in terms of sum and product type. Hence a list of Int will look like the code below.
\begin{minted}{C}
typedef struct Sum_unit_Prod_int_a {
    Label label;
    union {
        int left;
        Sum_unit_Prod_int_a *right;
    } value;
} Sum_unit_Prod_int_a
\end{minted}
However, we believe expressing typical recursive data structures like list of int in this way is bad for performances. Obviously, C has a more efficient way to represent list of int using an array. So we decided to has two ways to represent recursive data structures. For a set of specific recursive data structure, users can write their own representation to exploit the advantages of the target language. For example, a list of int are encoded in C using a wrapper of pointer type (shown in \coref{codegen:code:list}). This way is not very generic but friendly for performances. For other types of recursive data structures where user do not specify their optimized versions in C, we simply apply the method in the last paragraph to encode them in C. This way is generic but not efficient.
\begin{code}
\begin{minted}{C}
typedef struct List_int {
        size_t size; int * value;
    } List_int;
\end{minted}
\caption{Optimized represent of List in C}
\label{codegen:code:list}
\end{code}
\subsection{Compiling from Core to C} \label{codegen:sec:core}
\begin{listing}[ht]
    \begin{minipage}{.45\textwidth}
        \begin{displaymath}
            \inference[Var]{}{\toc{\text{Var n}} = \text{vn}}       
        \end{displaymath}
    \end{minipage}
    \hfill
    \begin{minipage}{.45\textwidth}
        \begin{displaymath}
            \inference[Lit]{}{\toc{\text{Lit val}} = \text{toC}(\text{val})}
        \end{displaymath}
    \end{minipage}
    \vskip\baselineskip
    \begin{minipage}{.45\textwidth}
    \begin{displaymath}
        \inference[Fst]{\toc{\text{a}} = c}{\toc{\text{Fst `ap` a}} = c.\text{fst}}        
    \end{displaymath}
    \end{minipage}
    \hfill
    \begin{minipage}{.45\textwidth}
    \begin{displaymath}
        \inference[Snd]{\toc{\text{a}} = c}{\toc{\text{Snd `ap` a}} = c.\text{snd}}        
    \end{displaymath}
    \end{minipage}
    \vskip\baselineskip
    \begin{minipage}{.45\textwidth}
    \begin{displaymath}
        \inference[Inl]{\toc{\text{a}} = c}{\toc{\text{Inl `ap` a}} = \{\text{LEFT}, c\}}
    \end{displaymath}
    \end{minipage}
    \hfill
    \begin{minipage}{.45\textwidth}
    \begin{displaymath}
        \inference[Inr]{\toc{\text{a}} = c}{\toc{\text{Inr `ap` a}} = \{\text{RIGHT}, c\}}
    \end{displaymath}
    \end{minipage}
    \vskip\baselineskip
    \begin{displaymath}
        \inference[Pair]{\toc{\text{a}} = c_1, \quad \toc{\text{b}} = c_2}{\toc{\text{Pair a b}} = \{c_1, c_2\}}
    \end{displaymath}
    \vskip\baselineskip
    \begin{minipage}{.45\textwidth}
    \begin{displaymath}
        \inference[Id]{\toc{\text{a}} = c}{\toc{\text{Id `ap` a}} = c}
    \end{displaymath}
    \end{minipage}
    \hfill
    \begin{minipage}{.45\textwidth}
    \begin{displaymath}
        \inference[Const]{\toc{\text{a}} = c, \quad \toc{\text{v}} = b}{\toc{\text{(Const v) `ap` a}} = b}
    \end{displaymath}
    \end{minipage}
    \vskip\baselineskip
    \begin{displaymath}
        \inference[Prim]{\toc{\text{a}} = c}{\toc{\text{(Prim fname fimpl) `ap' a}} = \text{fname}(c)} 
    \end{displaymath}
    \caption{Rules for compilation from Core to C}
    \label{codegen:rule}
\end{listing}
Core has a concise syntax so it does not require too much work to write a function that generate C expressions from Core expressions. Not surprisingly, the compilation is a traversal of the Core expression. Pattern matching on the structure of the core expression alters the behaviors of compilation. \hask{ap} (apply) constructor is used with an expression whose type is \hask{Core (a -> b)} and another expression whose type is \hask{Core b}. The code generation for \hask{ap} depends on the what the function expression is. The code generation rule is explained by the inference rules shown in \coref{codegen:rule}. $\toc{a}$ means the C code generated by Core expression \hask{a}. $\text{toC}$ is function that convert constant value in Haskell to constant value in C. 
\begin{itemize}
    \item \textbf{Var, Lit:} Code generation of Lit simply convert Haskell value to its corresponding C value. As for Var, it will be converted to a string literal composed of the variable identity prefixed by 'v'.
    \item \textbf{Fst, Inl, Pair\dots} For Inl and Inr and Pair, we used C99 style to initialize struct and union. The rule for generating corresponding struct are explained in the previous subsection. For Fst and Snd, we simply access the specific value using the designator.
    \item \textbf{Id, Const v:} Code generation of Id constructor is same as the code generation of the argument of the Id. Code generation of Const ignores the argument and use code generation of v expression instead.
    \item \textbf{Prim:} Prim constructor represents user defined functions. The code generation for function call of Prim is converted to function call by the name of the primitive function. Users can implement those functions in C and include them in the main generated file.
\end{itemize}

\subsection{The structure of generated C code}
We have covered the code generation algorithm for each process. We will now tackle how the generated code is structured from a group of interacting processes representing a parallel computation. For each process, we will generate its own C functions that take no argument. We decide to generate an addition C function since function is portable and acts like a black box hiding all the execution details so users can interact with generated code by calling the function. This function will take a parameter as input data and return the computation result. Inside, the function, it will spawn the same number of threads as the number of roles in the system. Each thread will execute the code which is generated from their corresponding Proc expression. In addition to that, the function will send the input parameter to the starting role in the group of Proc to kick off the computation using channel and waiting for the the ending role to send back the computation results. After it receive the result and all the threads have returned, it will return the result. We called this function \hask{proc0}.
\begin{listing}
    \inputminted{C}{codegen/total.c} 
    \caption{An example of generated code}
    \label{codegen:code:total}
\end{listing}

An example of the generated code is shown in \coref{codegen:code:total}. The code contains one process which received a list of int from \hask{proc0}, sort the input by an user defined function and then send the result to \hask{proc0}. We omit global channels declarations and data type declaration for simplicity. 

\section{Conclusion}
With the completion of code generation, we deliver the results we promised in the introduction section. We have implemented a end-to-end process that will generate low-level deadlock-free parallel code from an expressive high-level languages embedded with a flexible backend that can target multiple languages with ease. Now, it is time to evaluate the performances of our achievement with quantitative measurements.
% \subsubsection{Data type in C}
% \subsection{Optimization for common recursive data types in C}
% \subsection{Memory management}