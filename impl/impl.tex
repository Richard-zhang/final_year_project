\chapter{SPar: Implementation}
\section{Session types} \label{impl:sec:session}
Haskell does not have session type natively. Other encodings of session types in Haskell is an overkill to this project since Proc does not support all actions that can be typed by session types i.e. channel delegation. We decide to create our representation of session types in Haskell corresponding to set of actions supported by Proc. We will introduce two method for session typing the group of Proc programs followed by duality checking. One is at the value level and another is at the type level.
\subsection{Representations of session types in Haskell}
Session types belong to the family of behavior types. So the type looks very similar to the value that will be typed. We exploit this similarity to defined our session types in terms of free monad, the same method we have used in defining Proc.
\begin{listing}[ht]
    \inputminted{Haskell}{impl/type.hs}
    \caption{Session types in Haskell}
    \label{impl:code:type}
\end{listing}

The \coref{impl:code:type} shows the definition in Haskell. \hask{SType} is the session type in Haskell. It is parameterized by a type variable \hask{a} so that the value-level session types and the type-level session types can share the same basic definition of session types. \hask{S} is mapped to $! \langle p, S \rangle . T$. \hask{R} is mapped to $?(p, S).T$. \hask{B} is mapped to Branch type and \hask{Se} is mapped to Select type.
\subsection{Value-level duality check}
For the value-level session types, the type variable \hask{a} is instantiated with type \hask{TypeRep}. TypeRep reifies types to some extent by associating type representations to types \cite{DataTypeable}. Due to session types are represented as value expressions in Haskell, session typing a Proc program is the same as writing an interpreter which can be easily done since a Proc program is based on free monad. 

We traverses Proc programs converting each operation to its corresponding type in \hask{STypeF} and convert the value to its typeRep. For output actions, we recursively call the substructure to build the rest of session types. For input actions like \hask{Recv}, we will apply the continuation with the Core value constructed by\hask{Var} and recursively call the function on the result. The trick to apply \hask{Var} to the continuation make it possible to inspect the static structure of every Proc programs because \hask{b -> Proc a} is not inspectable i.e, we cannot pattern match on i, while \hask{Proc a} can be inspected. We will also use this trick in the code generation which will be introduced in later chapter.
\subsection{Type-indexed Free Monad}
\subsection{Type-level duality check}
\section{SPar interpreter} \label{impl:sec:interp}
\subsection{Overview}
SPar interpreter is an interpreter that interprets a group of Proc programs in Haskell. It can be considered as the simplest backend for evaluating SPar expressions. It records traces of the executions and the final output values of each Proc programs in the system. 

It focused on providing a reference implementation explaining the semantics of SPar expressions not on performance. In addition, SPar interpreter served as a very useful tool in the development of this project. We use it as prototype to quickly verify whether the computation produces produces the expected results. This feature is useful especially in the early stage of an implementation or during debugging.
\subsection{Implementation}
The implementation of SPar interpreter is standard. It is similar to the implementation of the scheduler we explained in the free monad section of the background chapter. In essence, it is a round robin scheduler for a group of Proc programs. 
\begin{listing}[ht]
\inputminted{Haskell}{impl/interp.hs}
\caption{Partial implementation of the SPar interpreter}
\label{impl:code:interp}
\end{listing}
A partial implementation can be seen in \coref{impl:code:interp}. It takes a list of Proc as a parameter and it maintain a state which is the combination of message queue, the trace and the list of output values. For the base case, the list is empty which means all processes has exited, it returns the trace and the list of output values. For the recursive case, it pattern matches on the first process at the beginning of the list. If the operation is Pure, it will update the list of output values, then abandon this process, and call itself recursively on the tail of the list. If the operation is an output action i.e, \hask{Send}, \hask{Select} or \hask{Broadcast}, it will update the message queue with the corresponding message containing the sender, the receiver and the value, then pop the head proc and append its next step to the end of list of Procs, and call the list recursively. If the operation is an input action i.e, \hask{Recv} or \hask{Branch}, it will first examine whether sender and receiver pairs match the pair from the message at the top of the message queue. If so, it applies the continuation with the value in the message, removes the message from the queue, removes the head of list, moves the result of applying continuation to the end of the list and calls the list recursively. If not, it simply moves the head of list to the end of list without changing the value of head process and call the list recursively. Because we have checked the duality of the processes in the system, it guarantee that for any input action, the required message will eventually appear at the head of the message queue in finite steps.

Also, the interpreter has a helper function that interpret Core expression into haskell value. This helper function is easy to write because operation on product or sum type has its own mapping function in Haskell and for the \hask{Prim} and \hask{Lit}, we can get their underlying Haskell implementation directly. As for \hask{Var}, this constructor is not intended to externally so we will not encounter.