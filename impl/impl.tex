\chapter{SPar: Implementation}
\section{Session types} \label{impl:sec:session}
\subsection{Representations of session types in Haskell}
\subsection{Type-indexed Free Monad}
\subsection{Type-level duality check}
\subsection{Value-level duality check}
\section{SPar interpreter} \label{impl:sec:interp}
\subsection{Overview}
SPar interpreter is an interpreter that interprets a group of Proc programs in Haskell. It can be considered as the simplest backend for evaluating SPar expressions. It records traces of the executions and the final output values of each Proc programs in the system. 

It focused on providing a reference implementation explaining the semantics of SPar expressions not on performance. In addition, SPar interpreter served as a very useful tool in the development of this project. We use it as prototype to quickly verify whether the computation produces produces the expected results. This feature is useful especially in the early stage of an implementation or during debugging.
\subsection{Implementation}
The implementation of SPar interpreter is standard. It is similar to the implementation of the scheduler we explained in the free monad section of the background chapter. In essence, it is a round robin scheduler for a group of Proc programs. 
\begin{listing}[ht]
\inputminted{Haskell}{impl/interp.hs}
\caption{Partial implementation of the SPar interpreter}
\label{impl:code:interp}
\end{listing}
A partial implementation can be seen in \coref{impl:code:interp}. It takes a list of Proc as a parameter and it maintain a state which is the combination of message queue, the trace and the list of output values. For the base case, the list is empty which means all processes has exited, it returns the trace and the list of output values. For the recursive case, it pattern matches on the first process at the beginning of the list. If the operation is Pure, it will update the list of output values, then abandon this process, and call itself recursively on the tail of the list. If the operation is an output action i.e, \hask{Send}, \hask{Select} or \hask{Broadcast}, it will update the message queue with the corresponding message containing the sender, the receiver and the value, then pop the head proc and append its next step to the end of list of Procs, and call the list recursively. If the operation is an input action i.e, \hask{Recv} or \hask{Branch}, it will first examine whether sender and receiver pairs match the pair from the message at the top of the message queue. If so, it applies the continuation with the value in the message, removes the message from the queue, removes the head of list, moves the result of applying continuation to the end of the list and calls the list recursively. If not, it simply moves the head of list to the end of list without changing the value of head process and call the list recursively. Because we have checked the duality of the processes in the system, it guarantee that for any input action, the required message will eventually appear at the head of the message queue in finite steps.

Also, the interpreter has a helper function that interpret Core expression into haskell value. This helper function is easy to write because operation on product or sum type has its own mapping function in Haskell and for the \hask{Prim} and \hask{Lit}, we can get their underlying Haskell implementation directly. As for \hask{Var}, this constructor is not intended to externally so we will not encounter.