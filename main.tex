\documentclass[a4paper, twoside, 11pt]{report}
%% Language and font encodings
\usepackage[english]{babel}
\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}

\usepackage{amsmath,amsthm,amssymb}
\usepackage{semantic}
\usepackage{afterpage}
\newcommand\blankpage{%
    \null
    \thispagestyle{empty}%
    \addtocounter{page}{-1}%
    \newpage}

\mathlig{|-}{\vdash}
\mathlig{->}{\rightarrow}
\newcommand*\Mp[2]{\text{Proc} \; #1 \; #2}

%% font size related
\linespread{1.15}
\setlength{\parskip}{5pt}

%% Chapter Beautify
\usepackage{titlesec}

%% Very nice Font
\usepackage{palatino}

%% Diagram drawing
\usepackage{tikz}
\usetikzlibrary{shapes.geometric, arrows}

%% Forced float
\usepackage{float}

%% Source code highlight
\usepackage{minted}
\usepackage{listings}
\usepackage{stmaryrd}
\newcommand*\toc[1]{\llbracket #1 \rrbracket}

%% figure

%% Code line references
\setminted[haskell]{escapeinside=\#\#, linenos=true, mathescape=true}
\usepackage{caption}
\usepackage{tikz}
\newcommand*\circled[1]{\tikz[baseline=(char.base)]{
            \node[shape=circle,draw,inner sep=1pt, text=white] (char) {#1};}}
\newcommand*\clabel[1]{$\label{#1} \circled{\ref{#1}}$}
\newcommand*\cref[1]{\circled{\ref{#1}}}
\newcommand*\ccaption[2]{
    \caption[.]{
        \centering #1\newline
        \begin{minipage}{\linewidth}
            #2
        \end{minipage}
        \newline
    }
}

\newenvironment{code}{\captionsetup{type=listing}}{}
%% Automatic Reference

% BNF Rule
\usepackage{mathtools,array}
\newenvironment{grammar}[2]
 {\begin{tabular}{@{\qquad}>{$}l<{$}@{\qquad}l@{}}
  \multicolumn{1}{@{}l@{}}{$#1$}&\multicolumn{1}{l@{}}{\hspace{-2em}#2}\\}
 {\end{tabular}}

%% Placeholder picture
\usepackage{mwe}

%% Format Paragraph
\setcounter{secnumdepth}{4}
\titleformat{\paragraph}
{\normalfont\normalsize\bfseries}{\theparagraph}{1em}{}
\titlespacing*{\paragraph}
{0pt}{3.25ex plus 1ex minus .2ex}{1.5ex plus .2ex}

%% Sets page size and margins
\usepackage[a4paper,top=3cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}

%% Useful packages
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage[colorlinks=true, allcolors=black]{hyperref}

%% Reference for figure, section and source code
\newcommand*{\charef}[1]{\chaptername~\ref{#1}}
\newcommand*{\tabref}[1]{\tablename~\ref{#1}}
\newcommand*{\figref}[1]{\figurename~\ref{#1}}
\newcommand*{\coref}[1]{\lstlistingname~\ref{#1}}
\newcommand*{\secref}[1]{Section~\ref{#1}}

%% Line number
% \usepackage{lineno}
% \linenumbers

%% for example
\usepackage{xspace}
\newcommand*{\eg}{e.g.\@\xspace}

%% Nested list
\usepackage{enumitem}
\setlist[enumerate]{label*=\arabic*.}

%% Haskell 
\newcommand*{\hask}[1]{\mintinline{text}{#1}}

%% https://tex.stackexchange.com/questions/375992/bad-mathchar-with-semantic-package
\usepackage{semantic}
\newcommand*{\Par}
{
    \: | \:
}

\title{TODO}
\author{Shuhao Zhang}
% Update supervisor and other title stuff in title/title.tex

\begin{document}
\input{title/title.tex}

\begin{abstract}
Parallel code is notorious for its difficulties in writing, verification and maintaining. However, with the end of Moore's law, CPUs evolve by including more cores. Modern programmers are expected to utilize the power of multi-core CPUs and face the challenges brought by parallel programs.

This project builds an embedded framework in Haskell to generate parallel code. Combining the power of multiparty session types with parallel computation, it creates a session typed monadic language as the middle layer and use the Arrow interface as an abstraction layer on top of the language. With the help of Arrow interface, we convert the data flow of the computation to communications and generate parallel codes according to the communication pattern. Thanks to the addition of session types, not only the generated code is guaranteed to be deadlock-free but also we gain a set of local types so that it is possible to reason about the communication structure of the parallel computation.

In order to show the framework is as expressive as usual programming languages, we write a few common parallel computation patterns and three algorithms to benchmarks using our framework. Benchmarks show users can express computation similar to traditional sequential code and gain a high-performance parallel code in low-level target languages for free. Also, the use case of the framework is not limited to a standalone tool for parallel computation; we show the framework can act as a code generation backend for other data-flow based high-level parallel languages with an example.
\end{abstract}


% \renewcommand{\abstractname}{Acknowledgements}
% \begin{abstract}
% TBD
% \end{abstract}

\tableofcontents
% \listoffigures
% \listoftables

\input{introduction/introduction.tex}
\input{background/background.tex}
\input{project/project.tex}
\input{spar/spar.tex}
\input{impl/impl.tex}
\input{arrow/arrow.tex}
\input{codegen/codegen.tex}
\input{eval/eval.tex}
% \chapter{Parallel algorithms and evaluation} \label{eval}
% \section{Parallelized algorithms}
% \subsection{Merge sort}
% \subsection{Quick sort}
% \section{Benchmarks}
% \subsection{Benchmarks against generated Haskell code}
% \subsection{Benchmarks against C implementation}
% \section{Evaluation}
% \subsection{Design choices: Why Haskell?}

\chapter{Conclusions and future work}
\section{Conclusions}
\section{Future work}

\bibliographystyle{ieeetr}
\bibliography{bibs/main}
\input{appendix/appendix.tex}
\end{document}