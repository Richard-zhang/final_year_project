
@incollection{coppoGentleIntroductionMultiparty2015,
  address = {{Cham}},
  title = {A {{Gentle Introduction}} to {{Multiparty Asynchronous Session Types}}},
  volume = {9104},
  isbn = {978-3-319-18940-6 978-3-319-18941-3},
  abstract = {This article provides a gentle introduction to multiparty session types, a class of behavioural types specifically targeted at describing protocols in distributed systems based on asynchronous communication. The type system ensures well-typed processes to enjoy non-trivial properties, including communication safety, protocol fidelity, as well as progress. The adoption of multiparty session types can positively affect the whole software lifecycle, from design to deployment, improving software reliability and reducing its development costs.},
  language = {en},
  booktitle = {Formal {{Methods}} for {{Multicore Programming}}},
  publisher = {{Springer International Publishing}},
  author = {Coppo, Mario and {Dezani-Ciancaglini}, Mariangiola and Padovani, Luca and Yoshida, Nobuko},
  editor = {Bernardo, Marco and Johnsen, Einar Broch},
  year = {2015},
  pages = {146-178},
  file = {/Users/r/Zotero/storage/PR6PURST/Coppo et al. - 2015 - A Gentle Introduction to Multiparty Asynchronous S.pdf},
  doi = {10.1007/978-3-319-18941-3_4}
}

@article{swierstraDataTypesCarte2008,
  title = {Data Types {\`a} La Carte},
  volume = {18},
  issn = {0956-7968, 1469-7653},
  abstract = {This paper describes a technique for assembling both data types and functions from isolated individual components. We also explore how the same technology can be used to combine free monads and, as a result, structure Haskell's monolithic IO monad.},
  language = {en},
  number = {04},
  journal = {Journal of Functional Programming},
  doi = {10.1017/S0956796808006758},
  author = {Swierstra, Wouter},
  month = jul,
  year = {2008},
  file = {/Users/r/Zotero/storage/C9YP5MUL/Swierstra - 2008 - Data types Ã  la carte.pdf}
}

@incollection{hughesProgrammingArrows2005,
  address = {{Berlin, Heidelberg}},
  title = {Programming with {{Arrows}}},
  volume = {3622},
  isbn = {978-3-540-28540-3 978-3-540-31872-9},
  language = {en},
  booktitle = {Advanced {{Functional Programming}}},
  publisher = {{Springer Berlin Heidelberg}},
  author = {Hughes, John},
  editor = {Hutchison, David and Kanade, Takeo and Kittler, Josef and Kleinberg, Jon M. and Mattern, Friedemann and Mitchell, John C. and Naor, Moni and Nierstrasz, Oscar and Pandu Rangan, C. and Steffen, Bernhard and Sudan, Madhu and Terzopoulos, Demetri and Tygar, Dough and Vardi, Moshe Y. and Weikum, Gerhard and Vene, Varmo and Uustalu, Tarmo},
  year = {2005},
  pages = {73-129},
  file = {/Users/r/Zotero/storage/ZSWY2TQT/Hughes - 2005 - Programming with Arrows.pdf},
  doi = {10.1007/11546382_2}
}

@article{MessagePassingInterface2018,
  title = {Message {{Passing Interface}}},
  copyright = {Creative Commons Attribution-ShareAlike License},
  abstract = {Message Passing Interface (MPI) is a standardized and portable message-passing standard designed by a group of researchers from academia and industry to function on a wide variety of parallel computing architectures.  The standard defines the syntax and semantics of a core of library routines useful to a wide range of users writing portable message-passing programs in C, C++, and Fortran.  There are several well-tested and efficient implementations of MPI, many of which are open-source or in the public domain.  These fostered the development of a parallel software industry, and encouraged development of portable and scalable large-scale parallel applications.},
  language = {en},
  journal = {Wikipedia},
  month = oct,
  year = {2018},
  file = {/Users/r/Zotero/storage/SP253PWS/index.html},
  note = {Page Version ID: 863149040}
}

@book{claessenFunctionalPearlsPoor1999,
  title = {Functional {{Pearls}}: {{A Poor Man}}'s {{Concurrency Monad}}},
  shorttitle = {Functional {{Pearls}}},
  abstract = {Without adding any primitives to the language, we define a concurrency monad transformer in Haskell. This allows us to add a limited form of concurrency to any existing monad. The atomic actions of the new monad are lifted actions of the underlying monad. Some extra operations, such as fork , to initiate new processes, are provided. We discuss the implementation, and use some examples to illustrate the usefulness of this construction.},
  author = {Claessen, Koen},
  year = {1999},
  file = {/Users/r/Zotero/storage/4FDU7RS7/Claessen - 1999 - Functional Pearls A Poor Man's Concurrency Monad.pdf;/Users/r/Zotero/storage/549VDJJD/summary.html}
}

@article{braunArrowsParallelComputation2018,
  archivePrefix = {arXiv},
  eprinttype = {arxiv},
  eprint = {1801.02216},
  primaryClass = {cs},
  title = {Arrows for {{Parallel Computation}}},
  abstract = {Arrows are a general interface for computation and an alternative to Monads for API design. In contrast to Monad-based parallelism, we explore the use of Arrows for specifying generalised parallelism. Specifically, we define an Arrow-based language and implement it using multiple parallel Haskells. As each parallel computation is an Arrow, such parallel Arrows (PArrows) can be readily composed and transformed as such. To allow for more sophisticated communication schemes between computation nodes in distributed systems, we utilise the concept of Futures to wrap direct communication. To show that PArrows have similar expressive power as existing parallel languages, we implement several algorithmic skeletons and four benchmarks. Benchmarks show that our framework does not induce any notable performance overhead. We conclude that Arrows have considerable potential for composing parallel programs and for producing programs that can execute on multiple parallel language implementations.},
  journal = {arXiv:1801.02216 [cs]},
  author = {Braun, Martin and Lobachev, Oleg and Trinder, Phil},
  month = jan,
  year = {2018},
  keywords = {Computer Science - Programming Languages},
  file = {/Users/r/Zotero/storage/A5E345TE/Braun et al. - 2018 - Arrows for Parallel Computation.pdf;/Users/r/Zotero/storage/DLISLFKZ/1801.html}
}

@incollection{meijerFunctionalProgrammingBananas1991,
  address = {{Berlin, Heidelberg}},
  title = {Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire},
  volume = {523},
  isbn = {978-3-540-54396-1 978-3-540-47599-6},
  abstract = {We develop a calculus for lazy functional programming based on recursion operators associated with data type de nitions. For these operators we derive various algebraic laws that are useful in deriving and manipulating programs. We shall show that all example functions in Bird and Wadler's \textbackslash{}Introduction to Functional Programming" can be expressed using these operators.},
  language = {en},
  booktitle = {Functional {{Programming Languages}} and {{Computer Architecture}}},
  publisher = {{Springer Berlin Heidelberg}},
  author = {Meijer, Erik and Fokkinga, Maarten and Paterson, Ross},
  editor = {Goos, Gerhard and Hartmanis, Juris and Hughes, John},
  year = {1991},
  pages = {124-144},
  file = {/Users/r/Zotero/storage/4394SS3X/Meijer et al. - 1991 - Functional programming with bananas, lenses, envel.pdf},
  doi = {10.1007/3540543961_7}
}

@article{elliottGenericFunctionalParallel2017b,
  title = {Generic Functional Parallel Algorithms: Scan and {{FFT}}},
  volume = {1},
  issn = {24751421},
  shorttitle = {Generic Functional Parallel Algorithms},
  language = {en},
  number = {ICFP},
  journal = {Proceedings of the ACM on Programming Languages},
  doi = {10.1145/3110251},
  author = {Elliott, Conal},
  month = aug,
  year = {2017},
  pages = {1-25},
  file = {/Users/r/Zotero/storage/R9966FDF/Elliott - 2017 - Generic functional parallel algorithms scan and F.pdf}
}

@misc{HaskellUnderstandingArrows,
  title = {Haskell/{{Understanding}} Arrows - {{Wikibooks}}, Open Books for an Open World},
  howpublished = {https://en.wikibooks.org/wiki/Haskell/Understanding\_arrows},
  file = {/Users/r/Zotero/storage/D5QGLMP6/Understanding_arrows.html}
}

@misc{mlotEnglishDataFlow2015,
  title = {English: {{Data}} Flow in the Mean1 Example of b:En:{{Haskell}}/{{Arrow}} Tutorial. {{Rectangles}} Are Arrows (Rounded Rectangles Are Arrows Made with Arr) and Circles Are Other Data Flow Split/Merge Points.},
  shorttitle = {English},
  author = {Mlot, Daniel},
  month = jul,
  year = {2015},
  file = {/Users/r/Zotero/storage/HL4E5HMD/FileUnderstanding_arrows_mean1_data_flow.html}
}

@article{marlowMonadDeterministicParallelism,
  title = {A {{Monad}} for {{Deterministic Parallelism}}},
  abstract = {We present a new programming model for deterministic parallel computation in a pure functional language. The model is monadic and has explicit granularity, but allows dynamic construction of dataflow networks that are scheduled at runtime, while remaining deterministic and pure. The implementation is based on monadic concurrency, which has until now only been used to simulate concurrency in functional languages, rather than to provide parallelism. We present the API with its semantics, and argue that parallel execution is deterministic. Furthermore, we present a complete workstealing scheduler implemented as a Haskell library, and we show that it performs at least as well as the existing parallel programming models in Haskell.},
  language = {en},
  author = {Marlow, Simon and Newton, Ryan and Jones, Simon Peyton},
  pages = {12},
  file = {/Users/r/Zotero/storage/XYFASX75/Marlow et al. - A Monad for Deterministic Parallelism.pdf}
}

@article{orchardSessionTypesLinearity,
  title = {Session {{Types}} with {{Linearity}} in {{Haskell}}},
  abstract = {Type systems with parametric polymorphism can encode a significant proportion of the information contained in session types. This allows concurrent programming with session-type-like guarantees in languages like ML and Java. However, statically enforcing the linearity properties of session types, in a way that is also natural to program with, is more challenging. Haskell provides various language features that can capture concurrent programming with session types, with full linearity invariants and in a mostly idiomatic style. This chapter overviews various approaches in the literature for session typed programming in Haskell.},
  language = {en},
  author = {Orchard, Dominic and Yoshida, Nobuko},
  pages = {24},
  file = {/Users/r/Zotero/storage/2PQSZG4D/Orchard and Yoshida - Session Types with Linearity in Haskell.pdf}
}

@article{milnerCalculusMobileProcesses1992,
  title = {A Calculus of Mobile Processes, {{I}}},
  volume = {100},
  issn = {08905401},
  language = {en},
  number = {1},
  journal = {Information and Computation},
  doi = {10.1016/0890-5401(92)90008-4},
  author = {Milner, Robin and Parrow, Joachim and Walker, David},
  month = sep,
  year = {1992},
  pages = {1-40},
  file = {/Users/r/Zotero/storage/TJYLRIXK/Milner et al. - 1992 - A calculus of mobile processes, I.pdf}
}

@article{hughesGeneralisingMonadsArrows2000,
  title = {Generalising Monads to Arrows},
  volume = {37},
  issn = {0167-6423},
  abstract = {Monads have become very popular for structuring functional programs since Wadler introduced their use in 1990. In particular, libraries of combinators are often based on a monadic type. Such libraries share (in part) a common interface, from which numerous benefits flow, such as the possibility to write generic code which works together with any library. But, several interesting and useful libraries are fundamentally incompatible with the monadic interface. In this paper I propose a generalisation of monads, which I call arrows, with significantly wider applicability. The paper shows how many of the techniques of monadic programming generalise to the new setting, and gives examples to show that the greater generality is useful. In particular, three non-monadic libraries for efficient parsing, building graphical user interfaces, and programming active web pages fit naturally into the new framework.},
  number = {1},
  journal = {Science of Computer Programming},
  doi = {10.1016/S0167-6423(99)00023-4},
  author = {Hughes, John},
  month = may,
  year = {2000},
  pages = {67-111},
  file = {/Users/r/Zotero/storage/EAYGK6J4/Hughes - 2000 - Generalising monads to arrows.pdf;/Users/r/Zotero/storage/DSJ9HHJD/S0167642399000234.html}
}

@article{castroAlgebraicMultipartyProtocol,
  title = {Algebraic {{Multiparty Protocol Programming}}},
  language = {en},
  journal = {Under submission},
  author = {Castro, David and Yoshida, Nobuko},
  pages = {37},
  file = {/Users/r/Zotero/storage/X4U5APQR/Algebraic Multiparty Protocol Programming.pdf}
}

@article{TacitProgramming2019,
  title = {Tacit Programming},
  copyright = {Creative Commons Attribution-ShareAlike License},
  abstract = {Tacit programming, also called point-free style, is a programming paradigm in which function definitions do not identify the arguments (or "points") on which they operate. Instead the definitions merely compose other functions, among which are combinators that manipulate the arguments. Tacit programming is of theoretical interest, because the strict use of composition results in programs that are well adapted for equational reasoning. It is also the natural style of certain programming languages, including APL and its derivatives, and concatenative languages such as Forth. The lack of argument naming gives point-free style a reputation of being unnecessarily obscure, hence the epithet "pointless style".UNIX scripting uses the paradigm with pipes.
For example, a sequence of operations in an applicative language such as the following Python code:

... is written in point-free style as the composition of a sequence of functions, without parameters:

The key idea in tacit programming is to assist in operating at the appropriate level of abstraction.  That is, to translate the natural transformation given by currying 

  
    
      
        hom
        â¡
        (
        A
        \texttimes{}
        B
        ,
        C
        )
        {$\cong$}
        hom
        â¡
        (
        B
        ,
        
          C
          
            A
          
        
        )
      
    
    \{\textbackslash{}displaystyle \textbackslash{}hom(A\textbackslash{}times B,C)\textbackslash{}cong \textbackslash{}hom(B,C\^\{A\})\}
  into computer functions, where the left represents the uncurried form of a function and the right the curried.  CA denotes the functionals from A to C (see also exponential object), while A \texttimes{} B denotes the Cartesian product of A and B.},
  language = {en},
  journal = {Wikipedia},
  month = jan,
  year = {2019},
  file = {/Users/r/Zotero/storage/M9F82TE7/index.html},
  note = {Page Version ID: 879102751}
}

@article{coleAlgorithmicSkeletonsStructured,
  title = {Algorithmic {{Skeletons}}: {{Structured Management}} of {{Parallel Computation}}},
  language = {en},
  author = {Cole, Murray I},
  pages = {137},
  file = {/Users/r/Zotero/storage/F3WW2PKG/Cole - Algorithmic Skeletons Structured Management of Pa.pdf}
}

@inproceedings{brownHeterogeneousParallelFramework2011,
  address = {{Galveston, TX, USA}},
  title = {A {{Heterogeneous Parallel Framework}} for {{Domain}}-{{Specific Languages}}},
  isbn = {978-1-4577-1794-9 978-0-7695-4566-0},
  abstract = {Computing systems are becoming increasingly parallel and heterogeneous, and therefore new applications must be capable of exploiting parallelism in order to continue achieving high performance. However, targeting these emerging devices often requires using multiple disparate programming models and making decisions that can limit forward scalability. In previous work we proposed the use of domain-specific languages (DSLs) to provide high-level abstractions that enable transformations to high performance parallel code without degrading programmer productivity. In this paper we present a new end-to-end system for building, compiling, and executing DSL applications on parallel heterogeneous hardware, the Delite Compiler Framework and Runtime. The framework lifts embedded DSL applications to an intermediate representation (IR), performs generic, parallel, and domain-specific optimizations, and generates an execution graph that targets multiple heterogeneous hardware devices. Finally we present results comparing the performance of several machine learning applications written in OptiML, a DSL for machine learning that utilizes Delite, to C++ and MATLAB implementations. We find that the implicitly parallel OptiML applications achieve single-threaded performance comparable to C++ and outperform explicitly parallel MATLAB in nearly all cases.},
  language = {en},
  booktitle = {2011 {{International Conference}} on {{Parallel Architectures}} and {{Compilation Techniques}}},
  publisher = {{IEEE}},
  doi = {10.1109/PACT.2011.15},
  author = {Brown, Kevin J. and Sujeeth, Arvind K. and Lee, Hyouk Joong and Rompf, Tiark and Chafi, Hassan and Odersky, Martin and Olukotun, Kunle},
  month = oct,
  year = {2011},
  pages = {89-100},
  file = {/Users/r/Zotero/storage/3UIYTAEC/Brown et al. - 2011 - A Heterogeneous Parallel Framework for Domain-Spec.pdf}
}

@article{liMapReduceParallelProgramming2016,
  title = {{{MapReduce Parallel Programming Model}}: {{A State}}-of-the-{{Art Survey}}},
  volume = {44},
  issn = {0885-7458, 1573-7640},
  shorttitle = {{{MapReduce Parallel Programming Model}}},
  language = {en},
  number = {4},
  journal = {International Journal of Parallel Programming},
  doi = {10.1007/s10766-015-0395-0},
  author = {Li, Ren and Hu, Haibo and Li, Heng and Wu, Yunsong and Yang, Jianxi},
  month = aug,
  year = {2016},
  pages = {832-866},
  file = {/Users/r/Zotero/storage/IIBXHBNU/Li et al. - 2016 - MapReduce Parallel Programming Model A State-of-t.pdf}
}

@misc{ControlMonadCont,
  title = {Control.{{Monad}}.{{Cont}}},
  howpublished = {http://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Cont.html},
  file = {/Users/r/Zotero/storage/3CSJXPWZ/Control-Monad-Cont.html}
}

@article{steuwerGeneratingPerformancePortable,
  title = {Generating {{Performance Portable Code}} Using {{Rewrite Rules}}},
  abstract = {Computers have become increasingly complex with the emergence of heterogeneous hardware combining multicore CPUs and GPUs. These parallel systems exhibit tremendous computational power at the cost of increased programming effort resulting in a tension between performance and code portability. Typically, code is either tuned in a low-level imperative language using hardware-specific optimizations to achieve maximum performance or is written in a high-level, possibly functional, language to achieve portability at the expense of performance.},
  language = {en},
  author = {Steuwer, Michel and Fensch, Christian and Dubach, Christophe and Lindley, Sam},
  pages = {14},
  file = {/Users/r/Zotero/storage/HHJNAKTB/Steuwer et al. - Generating Performance Portable Code using Rewrite.pdf}
}

@article{gayLinearTypeTheory2010,
  title = {Linear Type Theory for Asynchronous Session Types},
  volume = {20},
  issn = {0956-7968, 1469-7653},
  abstract = {Session types support a type-theoretic formulation of structured patterns of communication, so that the communication behaviour of agents in a distributed system can be verified by static typechecking. Applications include network protocols, business processes and operating system services. In this paper we define a multithreaded functional language with session types, which unifies, simplifies and extends previous work. There are four main contributions. First is an operational semantics with buffered channels, instead of the synchronous communication of previous work. Second, we prove that the session type of a channel gives an upper bound on the necessary size of the buffer. Third, session types are manipulated by means of the standard structures of a linear type theory, rather than by means of new forms of typing judgement. Fourth, a notion of subtyping, including the standard subtyping relation for session types (imported into the functional setting), and a novel form of subtyping between standard and linear function types, which allows the typechecker to handle linear types conveniently. Our new approach significantly simplifies session types in the functional setting, clarifies their essential features and provides a secure foundation for language developments such as polymorphism and object-orientation.},
  language = {en},
  number = {01},
  journal = {Journal of Functional Programming},
  doi = {10.1017/S0956796809990268},
  author = {Gay, Simon J. and Vasconcelos, Vasco T.},
  month = jan,
  year = {2010},
  pages = {19},
  file = {/Users/r/Zotero/storage/W8VKQB7L/Gay and Vasconcelos - 2010 - Linear type theory for asynchronous session types.pdf}
}

@article{svenningssonCombiningDeepShallow2015,
  title = {Combining Deep and Shallow Embedding of Domain-Specific Languages},
  volume = {44},
  issn = {14778424},
  abstract = {We present a technique to combine deep and shallow embedding in the context of compiling embedded languages in order to provide the benefits of both techniques. When compiling embedded languages it is natural to use an abstract syntax tree to represent programs. This is known as a deep embedding and it is a rather cumbersome technique compared to other forms of embedding, typically leading to more code and being harder to extend. In shallow embeddings, language constructs are mapped directly to their semantics which yields more flexible and succinct implementations. But shallow embeddings are not well-suited for compiling embedded languages.},
  language = {en},
  journal = {Computer Languages, Systems \& Structures},
  doi = {10.1016/j.cl.2015.07.003},
  author = {Svenningsson, Josef and Axelsson, Emil},
  month = dec,
  year = {2015},
  pages = {143-165},
  file = {/Users/r/Zotero/storage/5WI3NDZ9/Svenningsson and Axelsson - 2015 - Combining deep and shallow embedding of domain-spe.pdf}
}

@article{mcdonellTypesafeRuntimeCode,
  title = {Type-Safe {{Runtime Code Generation}}: {{Accelerate}} to {{LLVM}}},
  abstract = {Embedded languages are often compiled at application runtime; thus, embedded compile-time errors become application runtime errors. We argue that advanced type system features, such as GADTs and type families, play a crucial role in minimising such runtime errors. Specifically, a rigorous type discipline reduces runtime errors due to bugs in both embedded language applications and the implementation of the embedded language compiler itself. In this paper, we focus on the safety guarantees achieved by type preserving compilation. We discuss the compilation pipeline of Accelerate, a high-performance array language targeting both multicore CPUs and GPUs, where we are able to preserve types from the source language down to a low-level register language in SSA form. Specifically, we demonstrate the practicability of our approach by creating a new type-safe interface to the industrialstrength LLVM compiler infrastructure, which we used to build two new Accelerate backends that show competitive runtimes on a set of benchmarks across both CPUs and GPUs.},
  language = {en},
  author = {McDonell, Trevor L and Chakravarty, Manuel M T and Grover, Vinod and Newton, Ryan R},
  pages = {12},
  file = {/Users/r/Zotero/storage/WKLT7IV6/McDonell et al. - Type-safe Runtime Code Generation Accelerate to L.pdf}
}

@book{mccoolStructuredParallelPrograming2012,
  address = {{Amsterdam}},
  title = {Structured Parallel Programing: Patterns for Efficient Computation},
  isbn = {978-0-12-415993-8},
  lccn = {QA76.76.P37 M34 2012},
  shorttitle = {Structured Parallel Programing},
  language = {en},
  publisher = {{Elsevier, Morgan Kaufmann}},
  author = {McCool, Michael D. and Robison, Arch D. and Reinders, James},
  year = {2012},
  keywords = {Software patterns,Structured programming},
  file = {/Users/r/Zotero/storage/5S7MAHSU/McCool et al. - 2012 - Structured parallel programing patterns for effic.pdf}
}

@misc{ReifiedTypeHaskellWiki,
  title = {Reified Type - {{HaskellWiki}}},
  howpublished = {https://wiki.haskell.org/Reified\_type},
  file = {/Users/r/Zotero/storage/AWZLRZHE/Reified_type.html}
}

@article{Quickhull2019,
  title = {Quickhull},
  copyright = {Creative Commons Attribution-ShareAlike License},
  abstract = {Quickhull is a method of computing the convex hull of a finite set of points in the plane. It uses a divide and conquer approach similar to that of quicksort, from which its name derives. Its average case complexity is considered to be 
  
    
      
        O
        (
        n
        {${_\ast}$}
        l
        o
        g
        (
        n
        )
        )
      
    
    \{\textbackslash{}displaystyle O(n*log(n))\}
  , whereas in the worst case it takes 
  
    
      
        O
        (
        
          n
          
            2
          
        
        )
      
    
    \{\textbackslash{}displaystyle O(n\^\{2\})\}
   (quadratic). However, unlike quicksort, there is no obvious way to convert quickhull into a randomized algorithm. Thus, its average time complexity cannot be easily calculated.},
  language = {en},
  journal = {Wikipedia},
  month = jan,
  year = {2019},
  file = {/Users/r/Zotero/storage/NKY9NMRA/index.html},
  note = {Page Version ID: 879757605}
}

@article{eisenbergDEPENDENTTYPESHASKELLa,
  title = {{{DEPENDENT TYPES IN HASKELL}}: {{THEORY AND PRACTICE}}},
  language = {en},
  author = {Eisenberg, Richard A},
  pages = {351},
  file = {/Users/r/Zotero/storage/RLDFFGVJ/Eisenberg - DEPENDENT TYPES IN HASKELL THEORY AND PRACTICE.pdf}
}

@article{atkeyWhatCategoricalModel2011,
  title = {What Is a {{Categorical Model}} of {{Arrows}}?},
  volume = {229},
  issn = {15710661},
  abstract = {We investigate what the correct categorical formulation of Hughes' Arrows should be. It has long been folklore that Arrows, a functional programming construct, and Freyd categories, a categorical notion due to Power, Robinson and Thielecke, are somehow equivalent.},
  language = {en},
  number = {5},
  journal = {Electronic Notes in Theoretical Computer Science},
  doi = {10.1016/j.entcs.2011.02.014},
  author = {Atkey, Robert},
  month = mar,
  year = {2011},
  pages = {19-37},
  file = {/Users/r/Zotero/storage/52ZG2SYD/Atkey - 2011 - What is a Categorical Model of Arrows.pdf}
}

@article{langeVerifyingAsynchronousInteractions2019,
  archivePrefix = {arXiv},
  eprinttype = {arxiv},
  eprint = {1901.09606},
  primaryClass = {cs},
  title = {Verifying {{Asynchronous Interactions}} via {{Communicating Session Automata}}},
  abstract = {The relationship between communicating automata and session types is the cornerstone of many diverse theories and tools, including type checking, code generation, and runtime verification. A serious limitation of session types is that, while endpoint programs interact asynchronously, the underlying property which guarantees safety of session types is too synchronous: it requires a one-to-one synchronisation between send and receive actions. This paper proposes a sound procedure to verify properties of communicating session automata (csa), i.e., communicating automata that correspond to multiparty session types. We introduce a new asynchronous compatibility property for csa, called k-multiparty compatibility (k-mc), which is a strict superset of the synchronous multiparty compatibility proposed in the literature. It is decomposed into two bounded properties: (i) a condition called k-safety which guarantees that, within the bound, all sent messages can be received and each automaton can make a move; and (ii) a condition called k-exhaustivity which guarantees that all k-reachable send actions can be fired within the bound. We show that k-exhaustive systems soundly and completely characterise systems where each automaton behaves uniformly for any bound greater or equal to k. We show that checking k-mc is pspace-complete, but can be done efficiently over large systems by using partial order reduction techniques. We demonstrate that several examples from the literature are k-mc, but not synchronous compatible.},
  language = {en},
  journal = {arXiv:1901.09606 [cs]},
  author = {Lange, Julien and Yoshida, Nobuko},
  month = jan,
  year = {2019},
  keywords = {Computer Science - Programming Languages},
  file = {/Users/r/Zotero/storage/IWZGJTDX/Lange and Yoshida - 2019 - Verifying Asynchronous Interactions via Communicat.pdf}
}

@article{AmdahlLaw2019,
  title = {Amdahl's Law},
  copyright = {Creative Commons Attribution-ShareAlike License},
  abstract = {In computer architecture, Amdahl's law (or Amdahl's argument) is a formula which gives the theoretical speedup in latency of the execution of a task at fixed workload that can be expected of a system whose resources are improved. It is named after computer scientist Gene Amdahl, and was presented at the AFIPS Spring Joint Computer Conference in 1967.
Amdahl's law is often used in parallel computing to predict the theoretical speedup when using multiple processors. For example, if a program needs 20 hours using a single processor core, and a particular part of the program which takes one hour to execute cannot be parallelized, while the remaining 19 hours (p = 0.95) of execution time can be parallelized, then regardless of how many processors are devoted to a parallelized execution of this program, the minimum execution time cannot be less than that critical one hour. Hence, the theoretical speedup is limited to at most 20 times 
  
    
      
        
          (
          
            
              
                
                  1
                  
                    1
                    -
                    p
                  
                
              
            
            =
            20
          
          )
        
      
    
    \{\textbackslash{}displaystyle \textbackslash{}left(\{\textbackslash{}dfrac \{1\}\{1-p\}\}=20\textbackslash{}right)\}
  . For this reason, parallel computing with many processors is useful only for highly parallelizable programs.},
  language = {en},
  journal = {Wikipedia},
  month = may,
  year = {2019},
  file = {/Users/r/Zotero/storage/54MXJX64/index.html},
  note = {Page Version ID: 897444639}
}

@misc{DataTypeablea,
  title = {Data.{{Typeable}}},
  howpublished = {http://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Typeable.html},
  file = {/Users/r/Zotero/storage/IGM8SUPE/Data-Typeable.html}
}

@misc{Language,
  title = {Language.{{C}}},
  howpublished = {http://hackage.haskell.org/package/language-c-0.8.2/docs/Language-C.html},
  file = {/Users/r/Zotero/storage/IYXPM3KF/Language-C.html}
}

@misc{treatPureImplementationGo2019a,
  title = {Pure {{C}} Implementation of {{Go}} Channels. {{Contribute}} to Tylertreat/Chan Development by Creating an Account on {{GitHub}}},
  copyright = {Apache-2.0},
  howpublished = {https://github.com/tylertreat/chan},
  author = {Treat, Tyler},
  month = jun,
  year = {2019}
}

@misc{FreeMonadNLab,
  title = {Free Monad in {{nLab}}},
  howpublished = {https://ncatlab.org/nlab/show/free+monad},
  file = {/Users/r/Zotero/storage/599YYS6J/free+monad.html}
}

@misc{contributorsCatsFreeMonadsa,
  title = {Cats: {{FreeMonads}}},
  shorttitle = {Cats},
  abstract = {Lightweight, modular, and extensible library for functional programming},
  journal = {Cats},
  howpublished = {https://typelevel.org/cats/datatypes/freemonad.html},
  author = {{contributors}, Cats},
  file = {/Users/r/Zotero/storage/JFRXSEET/freemonad.html}
}

@inproceedings{marlowMonadDeterministicParallelism2011,
  title = {A Monad for Deterministic Parallelism},
  volume = {46},
  isbn = {1-4503-0860-0},
  booktitle = {{{ACM SIGPLAN Notices}}},
  publisher = {{ACM}},
  author = {Marlow, Simon and Newton, Ryan and Peyton Jones, Simon},
  year = {2011},
  pages = {71-82}
}

@book{coleAlgorithmicSkeletonsStructured1989,
  title = {Algorithmic Skeletons: Structured Management of Parallel Computation},
  isbn = {0-262-53086-4},
  publisher = {{Pitman London}},
  author = {Cole, Murray I.},
  year = {1989}
}

@inproceedings{ngProtocolsDefault2015,
  series = {Lecture {{Notes}} in {{Computer Science}}},
  title = {Protocols by {{Default}}},
  isbn = {978-3-662-46663-6},
  abstract = {This paper presents a code generation framework for type-safe and deadlock-free Message Passing Interface (MPI) programs. The code generation process starts with the definition of the global topology using a protocol specification language based on parameterised multiparty session types (MPST). An MPI parallel program backbone is automatically generated from the global specification. The backbone code can then be merged with the sequential code describing the application behaviour, resulting in a complete MPI program. This merging process is fully automated through the use of an aspect-oriented compilation approach. In this way, programmers only need to supply the intended communication protocol and provide sequential code to automatically obtain parallelised programs that are guaranteed free from communication mismatch, type errors or deadlocks. The code generation framework also integrates an optimisation method that overlaps communication and computation, and can derive not only representative parallel programs with common parallel patterns (such as ring and stencil), but also distributed applications from any MPST protocols. We show that our tool generates efficient and scalable MPI applications, and improves productivity of programmers. For instance, our benchmarks involving representative parallel and application-specific patterns speed up sequential execution by up to 31 times and reduce programming effort by an average of 39\%.},
  language = {en},
  booktitle = {Compiler {{Construction}}},
  publisher = {{Springer Berlin Heidelberg}},
  author = {Ng, Nicholas and {de Figueiredo Coutinho}, Jose Gabriel and Yoshida, Nobuko},
  editor = {Franke, Bj{\"o}rn},
  year = {2015},
  keywords = {Kernel Function,Loop Condition,Message Pass Interface,Parallel Application,Session Type},
  pages = {212-232},
  file = {/Users/r/Zotero/storage/I7ERCDKM/Ng et al. - 2015 - Protocols by Default.pdf}
}

@article{orchardSessionTypesLinearity2017,
  title = {Session Types with Linearity in {{Haskell}}},
  journal = {Behavioural Types: from Theory to Tools},
  author = {Orchard, Dominic and Yoshida, Nobuko},
  year = {2017},
  pages = {219}
}

@article{claessenPoorManConcurrency1999,
  title = {A Poor Man's Concurrency Monad},
  volume = {9},
  number = {3},
  journal = {Journal of Functional Programming},
  author = {Claessen, Koen},
  year = {1999},
  pages = {313-323}
}

@article{mcdonellTypesafeRuntimeCode2016,
  title = {Type-Safe Runtime Code Generation: Accelerate to {{LLVM}}},
  volume = {50},
  number = {12},
  journal = {ACM SIGPLAN Notices},
  author = {McDonell, Trevor L. and Chakravarty, Manuel MT and Grover, Vinod and Newton, Ryan R.},
  year = {2016},
  pages = {201-212}
}

@article{barberQuickhullAlgorithmConvex1996,
  title = {The Quickhull Algorithm for Convex Hulls},
  volume = {22},
  number = {4},
  journal = {ACM Transactions on Mathematical Software (TOMS)},
  author = {Barber, C. Bradford and Dobkin, David P. and Dobkin, David P. and Huhdanpaa, Hannu},
  year = {1996},
  pages = {469-483}
}

@inproceedings{amdahlValiditySingleProcessor1967,
  title = {Validity of the Single Processor Approach to Achieving Large Scale Computing Capabilities},
  booktitle = {Proceedings of the {{April}} 18-20, 1967, Spring Joint Computer Conference},
  publisher = {{ACM}},
  author = {Amdahl, Gene M.},
  year = {1967},
  pages = {483-485}
}

@misc{MessagePassingInterface,
  title = {Message {{Passing Interface}}},
  howpublished = {https://www.mcs.anl.gov/research/projects/mpi/},
  file = {/Users/r/Zotero/storage/SGVXHQQU/mpi.html}
}


