% \chapter{Design and Implementation}
\chapter{TBD:the theory and the practice}
\section{Parallel algebraic language} \label{b:pal}
Parallel algebraic language (PAL) is an example of the high-level languages to generate parallel code, proposed in the paper \cite{authorAlgebraicMultipartyProtocol2018}. In this project, a translation rule from this languages to the intermediate languages will be introduced.
\subsection{Syntax}
Besides primitives type like int, unit and function types, PAL use four functors to form more types hence representing complicated data structures by composing them (seen in table). For example, a list of integer is expressed in \coref{p:pal:c1}.
\begin{table}[ht]
\begin{grammar}{F_1, F_2 \Coloneqq}{}
    I & Identity functor\\
    K t & Constatnt functor\\
    F_1 + F_2 & Sum functor\\
    F_1 \times F_2 & Product functor
\end{grammar}
\hfill
\begin{grammar}{t_1, t_2 \Coloneqq}{Type}
    () \mid \text{int} \mid \dots & Primitive types\\
    F \ t_1 & Functor types\\
    \mu .F & Recursive types\\
\end{grammar}
\caption{Functor and Type definitions}
\end{table}
\begin{code}
\begin{lstlisting}{language=Haskell}
    newtype L = K () + K Int * I
    type List = Rec L
\end{lstlisting}
\caption{Type of integer list in PAL}
\label{p:pal:c1}
\end{code}

An important feature of PAL is the lack of usual control flow like if branch or while loop, instead, it uses data structures to replace control flow. Data structures in PAL not only store data but also serves as control structures. It uses the idea of recursion schemes (seen in \secref{b:rs}) to build sophiscated algorithms. 

To summary, algorithms in PAL are represented as a series of transformations of data, making it easy to transform the PAL programmes to programmes in arrows mechanically since arrows also express flow of data and their transformations naturally. This property allows us to generate parallel code without burnders.

\subsection{Example: Merge sort}

Like the merge sort example in \secref{b:rs:ex}, PAL make these recursion shcemes built-in and hence express computation. A merge sort in PAL is shown in \coref{p:pal:c5}
\begin{code}
\begin{lstlisting}[language=haskell]
poly T = K (() + int) + I * I;
poly L = K () + K int * I;

atom split : Rec L -> T Rec L;

atom merge : T Rec L -> Rec L;

fun ms : Rec L -> Rec L
  = rec [T] merge split;
\end{lstlisting}
\caption{Merge sort in PAL} \label{p:pal:c5}
\end{code}
\subsection{Code generation}