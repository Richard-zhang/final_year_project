\chapter{Type-safe code generation from SPar}
SPar has two components: Core representing the unit of computation and Proc as a skeleton of the computation, describing the communication patterns. Naturally, the process of code generation from SPar should be divided into two parts correspondingly. We choose to make two parts independent of each other so that it's possible to swap the code generation strategy of one component without modifying another one.

The procedure of code generation is standard: transformation. We start our programs in a high level DSL and run a series of transformation to low-level DSL. SPar expressions are converted to a low-level EDSL which is then transformed to an abstract syntax tree (AST) of C (TODO cite the package). The generated code is obtained by pretty printing the AST.
\section{Instr: A low-level EDSL for channel communication}
In Proc, we have high-level actions like select, broadcast and branch abstracting implementation details, i.e variable declaration, variable assignment, channel initialization, channel communication and channel deletion. Hence, we need to define a EDSL containing instructions related to these low-level operations. We name it Instr. A Spar programs will be translated to a sequence of Instr.
\subsection{Syntax and semantic}
\begin{listing}
    \inputminted{Haskell}{codegen/instr.hs} 
    \caption{The syntax of Instr in Haskell with accompanying low-level data types}
    \label{codegen:code:instr}
\end{listing}
The definition of Instr is seen in \coref{codegen:code:instr}. \hask{Channel} is our abstract representation of Channel in Instr. It is indexed by a type a from the reified type \hask{ReprType a}. More details of this reified type will be introduced in \secref{codegen:sec:repr}. This type parameter preserves type in channel initialization hence make sure the value to be sent or received in this channel has the same type as this channel. This is necessary because for some target languages, the channel are typed. Similarly, type parameters in \hask{Exp} have the same functionality. \hask{Exp} is just a wrapper of the expression in Core. In later stages, we will take care of code generation of \hask{Exp} along with \hask{Instr}. \hask{Instr} defines the set of statements that will be generated and \hask{Exp} represents the sequential computation, which is a value that will be generated.

The semantic of Instr operations are similar to what their names suggest. \hask{CInitChan} represents operations that initialize a channel according to the given type and cid. \hask{CDeleteChan} will destroy a channel. \hask{CSend} operation sends the value \hask{Exp a} through the Channel. \hask{CRecv} action means the value received in the channel will be assigned to variable whose postfix name is the int field. \hask{CEnd} means the instruction exits with the value \hask{Exp a}. \hask{CDecla} and \hask{CAssgn} are instructions for variable declaration and assignment. The type of the variable is determined by \hask{ReprType a} and the value is \hask{Exp a}. \hask{CBranch} and \hask{CSelect} are used to express conditional control flow of the Instr languages. SPar action like broadcast are built on top of these operations. For \hask{CBranch}, the first field represents the value of Either type to be received via the channel and two \hask{Seq Instr}s represents the sequence of \hask{Instr}s in the left branch and the right branch. For \hask{CSelect}, the first field represents the variable containing Either value and the second field field represents the variable whose value is assigned by the end results of instructions from either the left branch or the right branch. The third and fourth fields represent the instructions in the left branch and the right branch.

\subsection{Representation types} \label{codegen:sec:repr}
SPar programs cannot be fully parametric since the target languages of code generation from SPar are usually less expressive, i.e, they do not treat function type \hask{a->b} as a value, and are less efficient when processing with some specific form of data, i.e, languages targeting GPUs are usually more productive in dealing with array of floating point number while slow in working with aggregate structures \cite{mcdonellTypesafeRuntimeCode}. 
\begin{listing}
    \inputminted{Haskell}{codegen/repr.hs}    
    \caption{The definition of representation types}
    \label{codegen:code:repr}
\end{listing}
\begin{listing}
    \inputminted{Haskell}{codegen/const.hs} 
    \caption{An example usage of reified type in the code generation}
    \label{codegen:code:const}
\end{listing}
Hence, we need to restrict the set of types allowed in SPar. We achieve this using the type class \hask{Repr} and corresponding reified type \hask{ReprType} (shown in \coref{codegen:code:repr}). \hask{Repr} determines the set of type allow in SPar. Reified type \hask{ReprType} will be used to alter the behaviors of code generation based on the type. This can be simply done by pattern matching because reified types are values in Haskell \cite{ReifiedTypeHaskellWiki}. To be more concrete, \coref{codegen:code:const} gives a demo. \hask{constToCExpr} is function that handle code generation from constant value to expression in C programming languages. By pattern matching, we vary the behaviors of code generation so that constants with different types has their own way to be represented in C.

In conclusion, we allow the following type: numerical type like \hask{Float} and \hask{Int}, the unit type \hask{()}, the label type which is used in the code generation of select and branch and the aggregate type: list, product and sum that are built recursively, to be expressed in SPar.

\section{Compilation from SPar to Instr}
% \subsection{Two stages of compilation}
\subsection{Transformation from Proc to Instr}
As described in the previous section, Instr contains a data type called \hask{Exp} which is a wrapper of Core expression. Compiling Core to Instr is hence not difficult. The challenge of compiling Core is mainly how to compile it to a specific target language. This will be discussed in the next subsection.  

In this section, we will explain how we transform operations in Proc to Instr. Generally speaking, each Proc operation is mapped to a sequence of actions in Instr. The transformation algorithm from a Proc expression to a sequence of Instr can be implemented easily by traversing Proc expression, applying the mapping and collecting the results by concatenation. This is an advantage of using free monad technique to build the AST because Proc expression can be treated as a data structures and traversing recursive data structures can be easily done in Haskell. In addition, operations like \hask{Recv} which involves continuation whose type is \hask{Core a -> next} in their constructors are treated differently than those operations whose constructors only have a value type \hask{next}. The latter is easy to implement, we can simply call the traversing function recursively. For the former, we have to pass an expression whose type is \hask{Core a} to the continuation so that we can recursively call the traverse function recursively on the results of applying value to the continuation. The answer to what Core expression should be used is \hask{Var} denoting variable. Passing a unique variable to the continuation gives us \hask{next} inexpensively and we will define where does values of variables comes from for each operations in Proc. 

We have introduced the general principle to the readers. Now let us dig into details of translation rules for each operations. 

\begin{itemize}
    \item     
\end{itemize}

\subsection{Strategies for channel allocation}
\subsection{Type preservation}
\section{Code generation to C: from Instr to C}
\subsection{Representations of Core data type in C}
% \subsubsection{Data type in C}
% \subsection{Optimization for common recursive data types in C}
% \subsection{Memory management}